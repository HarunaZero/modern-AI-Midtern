# -*- coding: utf-8 -*-
"""py_sample.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v3KigSelUjBA0PXRATtkVcnSo9Ltfb16
"""

#!/usr/bin/env python3
import rospy
import numpy as np
import math
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion

# Global variables
robot = {'x': 0.0, 'y': 0.0, 't': 0.0}
goal = {'x': 0.0, 'y': 2.0}
laser = [float('inf')] * 5
W = np.zeros(4)
current_action = 3
terminal = False

def motion_model(robot_t_1, a, dt):
    VW_v = 3 * 5
    VW_w = (np.pi / 12) * (3 - a)
    return {
        'x': robot_t_1['x'] + VW_v * np.cos(robot_t_1['t']) * dt,
        'y': robot_t_1['y'] + VW_v * np.sin(robot_t_1['t']) * dt,
        't': robot_t_1['t'] + VW_w * dt
    }

def features(robot, goal, laser, a):
    dt = 0.1
    next_state = motion_model(robot, a, dt)

    move_vec = np.array([np.cos(next_state['t']), np.sin(next_state['t'])])
    goal_vec = np.array([goal['x'] - robot['x'], goal['y'] - robot['y']])

    if np.linalg.norm(goal_vec) > 0:
        goal_vec = goal_vec / np.linalg.norm(goal_vec)

    cos_angle = np.dot(move_vec, goal_vec)
    cos_angle = np.clip(cos_angle, -1.0, 1.0)
    f3 = np.arccos(cos_angle)

    f1 = 1
    f2 = np.linalg.norm([goal['x'] - next_state['x'], goal['y'] - next_state['y']]) / 100
    f4 = f3 if laser[a - 1] <= 70 else -f3

    return np.array([f1, f2, f3, f4])

def q_value(a, W, robot, goal, laser):
    return np.dot(W, features(robot, goal, laser, a))

def Q_learning(a, W, robot, goal, laser, R, terminal):
    epsilon = 0.3
    dt = 0.1
    gamma = 0.9
    alpha = 0.05

    if np.random.rand() < epsilon:
        opt_a = np.random.randint(1, 6)
    else:
        q_vals = np.array([np.dot(W, features(robot, goal, laser, i + 1)) for i in range(5)])
        opt_a = np.argmax(q_vals) + 1

    robot_next = motion_model(robot, a, dt)
    q_next = np.array([q_value(i + 1, W, robot_next, goal, laser) for i in range(5)])

    td_target = R if terminal else R + gamma * np.max(q_next)
    q_current = np.dot(W, features(robot, goal, laser, a))
    td_error = td_target - q_current

    Wt = W + alpha * td_error * features(robot, goal, laser, a)
    return opt_a, Wt

def reward(robot, goal, obs):
    R = -0.05
    Terminal = False

    dis_goal = np.linalg.norm([goal['x'] - robot['x'], goal['y'] - robot['y']])
    dis_obs = np.linalg.norm([obs['x'] - robot['x'], obs['y'] - robot['y']])

    if robot['x'] <= 5 or robot['x'] >= 295 or robot['y'] <= 5 or robot['y'] >= 295:
        R = -10
        Terminal = True

    elif dis_goal <= 10:
        R = 10
        Terminal = True

    elif dis_obs <= 10:
        R = -10
        Terminal = True

    return R, Terminal

# ROS callbacks
def odomCallback(msg):
    global robot
    robot['x'] = msg.pose.pose.position.x
    robot['y'] = msg.pose.pose.position.y
    orientation_q = msg.pose.pose.orientation
    (_, _, yaw) = euler_from_quaternion([orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w])
    robot['t'] = yaw

def scanCallback(msg):
    global laser
    n = len(msg.ranges)
    indices = [n // 6, n // 3, n // 2, 2 * n // 3, 5 * n // 6]
    laser = [min(msg.ranges[i], 100.0) for i in indices]

def step(event):
    global current_action, W, robot, goal, laser, terminal

    obs = {'x': 0.0, 'y': 1.0}
    R, terminal = reward(robot, goal, obs)

    current_action, W = Q_learning(current_action, W, robot, goal, laser, R, terminal)

    # Actuate robot
    cmd = Twist()
    VW_v = 3 * 5
    VW_w = (np.pi / 12) * (3 - current_action)
    cmd.linear.x = VW_v
    cmd.angular.z = VW_w
    pub.publish(cmd)

# Main
if __name__ == '__main__':
    rospy.init_node('q_learning_navigator')
    pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
    rospy.Subscriber('/odom', Odometry, odomCallback)
    rospy.Subscriber('/scan', LaserScan, scanCallback)
    rospy.Timer(rospy.Duration(0.1), step)
    rospy.spin()